네, 알겠습니다.

이전 리뷰에서 지적된 \*\*핵심 리스크 1, 2번 (API 오류 처리 누락, 지역명 검색 로직 퇴보)\*\*을 해결하는 패치를 적용한 전체 코드입니다. 이 코드는 안정성과 검색 정확도가 개선되어 "보완 후 배포"가 가능한 수준입니다.

-----

### **체감온도 API 개선안 최종본 (pt.js)**

```javascript
/**
 * /api/pt.js
 * 체감온도(여름, KMA2016) + 초단기실황(getUltraSrtNcst) 기반 실시간 안전경보 API
 *
 * 포함 기능
 * 1) 데이터 소스 전환: getVilageFcst(3시간) → getUltraSrtNcst(1시간, 실황)
 * 2) REFRESH_INTERVAL 상수화(가이드 기준 1시간 주기)
 * 3) 법정 조치문 자동 안내(action) 포함
 * 4) 조회 기록 로깅(콘솔 + 파일 JSON Lines)
 * 5) 10분 in-memory 캐시
 *
 * 필요 환경변수: process.env.KMA_SERVICE_KEY  (공공데이터포털 발급 키)
 */

import fs from "fs";
import path from "path";
// 경로는 저장소에 맞게 조정
import nxnyDB from "../lib/nxny_map.json" assert { type: "json" };

// ------------------------------
// 상수: API/캐시/로깅
// ------------------------------

// 기상청 초단기실황 엔드포인트 (가이드 명시, https 적용)
// (실황: 정시 생성, 매시 10분 이후 최신 제공. base_date=YYYYMMDD, base_time=HH00)
[cite_start]// 참고: 가이드 엔드포인트 및 파라미터 명세 [cite: 85]
const KMA_ULTRA_NCST_URL =
  "https://apis.data.go.kr/1360000/VilageFcstInfoService_2.0/getUltraSrtNcst";

[cite_start]// (가이드: 초단기실황 1시간 주기) [cite: 85]
export const REFRESH_INTERVAL_MS = 60 * 60 * 1000;
// 동일 요청 10분 캐시
const CACHE_TTL_MS = 10 * 60 * 1000;
// 로그 파일 (JSON Lines)
const LOG_DIR = path.join(process.cwd(), "logs");
const LOG_FILE = path.join(LOG_DIR, "pt_log.jsonl");

// in-memory 캐시 (key: `${nx},${ny}`)
const cache = new Map();

// ------------------------------
// 유틸: KST 시각, 포맷
// ------------------------------
const toKST = (date = new Date()) =>
  new Date(date.getTime() + 9 * 60 * 60 * 1000);
const pad2 = (n) => String(n).padStart(2, "0");
const yyyymmdd = (d) =>
  `${d.getUTCFullYear()}${pad2(d.getUTCMonth() + 1)}${pad2(d.getUTCDate())}`;
const hhmm = (d) => `${pad2(d.getUTCHours())}${pad2(d.getUTCMinutes())}`;

/**
 * 초단기실황 base_date/base_time 계산
 * - 정시 생성, 매시 10분 이후 제공이므로 분<10이면 직전시로 내림
 * (가이드 표 명시) [cite_start][cite: 167]
 */
function getUltraBaseDateTime(nowUTC = new Date()) {
  const nowKST = toKST(nowUTC);
  const kst = new Date(nowKST.getTime());
  if (kst.getUTCMinutes() < 10) {
    kst.setUTCHours(kst.getUTCHours() - 1);
  }
  kst.setUTCMinutes(0, 0, 0);
  return {
    base_date: yyyymmdd(kst), // "YYYYMMDD"
    base_time: `${pad2(kst.getUTCHours())}00`, // "HH00"
  };
}

// ------------------------------
// 주소→격자(nx, ny) 매칭 (수정: 약칭 검색 로직 복원)
// ------------------------------
function normalize(s) {
  return s.replace(/\s+/g, "").toLowerCase();
}

function findNxNy(input) {
  if (!input || typeof input !== "string") return null;
  const q = normalize(input);

  // 1) 완전일치
  for (const key of Object.keys(nxnyDB)) {
    if (normalize(key) === q) return nxnyDB[key];
  }

  // 2) 부분일치(가장 긴 키 우선)
  const keys = Object.keys(nxnyDB).sort((a, b) => b.length - a.length);
  for (const key of keys) {
    if (normalize(key).includes(q)) return nxnyDB[key];
  }

  // 3) 단어조합(모든 토큰 포함)
  const tokens = input.split(/\s+/).filter(Boolean);
  for (const key of keys) {
    const nk = normalize(key);
    if (tokens.every((t) => nk.includes(normalize(t)))) return nxnyDB[key];
  }
  
  // 4) [복원] 약칭 동명 검색 (예: "역삼동" -> "서울특별시 강남구 역삼동")
  const multiHits = keys.filter((key) => normalize(key).endsWith(q));
  if (multiHits.length > 0) {
    // 여러 후보 중 가장 짧은 전체 이름을 가진 것을 우선 (예: '종로구' vs '종로1가동')
    multiHits.sort((a, b) => a.length - b.length);
    return nxnyDB[multiHits[0]];
  }

  return null;
}

// ------------------------------
// 체감온도(KMA2016, 여름) 계산
//  - Stull 기반 Tw 근사 → KMA 2016 공식
// ------------------------------
function perceivedTempKMA(Ta, RH) {
  // 습구온도 근사 (Stull)
  const Tw =
    Ta * Math.atan(0.151977 * Math.sqrt(RH + 8.313659)) +
    Math.atan(Ta + RH) -
    Math.atan(RH - 1.676331) +
    0.00391838 * Math.pow(RH, 1.5) * Math.atan(0.023101 * RH) -
    4.686035;
  // KMA 2016 apparent temperature (여름)
  const PT =
    -0.2442 + 0.55399 * Tw + 0.45535 * Ta - 0.0022 * Tw * Tw + 0.00278 * Tw * Ta + 3.0;
  return Math.round(PT * 10) / 10; // 소수1자리
}

function levelByPT(pt) {
  if (pt >= 40) return "위험";
  if (pt >= 38) return "경고";
  if (pt >= 35) return "주의";
  if (pt >= 32) return "관심";
  return "정상";
}

/**
 * 법정/운영 조치문 매핑
 * - 기본 법적 관리기준을 강조: 31℃ 이상(폭염작업) 여부 플래그 제공
 * - 단계별 조치문은 산업현장 운영 예시(내부정책으로 변경 가능)
 */
const LEGAL_MIN_PT = 31;
function actionByLevel(level, pt) {
  // 단계별 기본 조치 예시 (필요 시 문구/시간조정 가능)
  const byLevel = {
    정상:
      "정상: 물·그늘·휴식 준비상태 유지, 열질환자 교육/증상 모니터링을 지속하세요.",
    관심:
      "관심(≥32℃): 작업 전 점검 강화, 1시간당 10분 이상 휴식 권고, 수분·염분 보충을 강화하세요.",
    주의:
      "주의(≥35℃): 2시간마다 20분 이상 휴식, 중노동 축소·교대작업, 취약 근로자 보호조치를 시행하세요.",
    경고:
      "경고(≥38℃): 1시간 기준 15~20분 이상 휴식, 불가피한 경우 작업강도 대폭 축소·순환작업, 응급대응 준비 상태를 유지하세요.",
    위험:
      "위험(≥40℃): 즉시 작업중지 및 대피, 응급조치 체계를 가동하고 관리자 판단하에 재개 여부를 결정하세요.",
  };
  const base = byLevel[level] || byLevel["정상"];

  // 31℃(폭염작업) 법적 기준 도달 시 강조 메시지 부가
  if (pt >= LEGAL_MIN_PT) {
    return `${base} (법정기준 도달: 체감온도 ${LEGAL_MIN_PT}℃ 이상 구간에 해당하므로 보호조치를 의무적으로 이행하세요.)`;
  }
  return base;
}

// ------------------------------
// 초단기실황 호출 (T1H, REH, WSD)
// ------------------------------
async function fetchUltraNcst({ nx, ny }) {
  const { base_date, base_time } = getUltraBaseDateTime();
  const params = new URLSearchParams({
    serviceKey: process.env.KMA_SERVICE_KEY,
    numOfRows: "100",
    pageNo: "1",
    dataType: "JSON",
    base_date,
    base_time,
    nx: String(nx),
    ny: String(ny),
  });
  const url = `${KMA_ULTRA_NCST_URL}?${params.toString()}`;
  const res = await fetch(url);
  if (!res.ok) {
    throw new Error(`KMA HTTP ${res.status}`);
  }
  const json = await res.json();

  [cite_start]// [수정] API 응답 헤더의 resultCode 검증 로직 추가 [cite: 382]
  if (json?.response?.header?.resultCode !== "00") {
    const { resultCode, resultMsg } = json.response.header;
    throw new Error(
      `KMA API Error: ${resultCode} - ${resultMsg}`
    );
  }
  
  const items = json?.response?.body?.items?.item || [];
  [cite_start]// category → obsrValue 맵 (예: T1H, REH, WSD 등) [cite: 133]
  const mm = Object.fromEntries(items.map((it) => [it.category, it.obsrValue]));
  const t = mm.T1H != null ? parseFloat(mm.T1H) : null; // 기온(℃)
  const rh = mm.REH != null ? parseFloat(mm.REH) : null; // 습도(%)
  const wsd = mm.WSD != null ? parseFloat(mm.WSD) : null; // 풍속(m/s)

  return {
    base_date,
    base_time,
    temperature: t,
    humidity: rh,
    windSpeed: wsd,
    raw: json,
  };
}

// ------------------------------
// 캐싱: 동일 지역(nx,ny) 10분 재사용
// ------------------------------
function getCache(key) {
  const hit = cache.get(key);
  if (!hit) return null;
  const age = Date.now() - hit.savedAt;
  if (age <= CACHE_TTL_MS) {
    return { ...hit, cacheAgeMs: age, cacheHit: true };
  }
  cache.delete(key);
  return null;
}
function setCache(key, value) {
  cache.set(key, { ...value, savedAt: Date.now(), cacheHit: false });
}

// ------------------------------
// 로깅: JSON Lines (콘솔 + 파일)
// ------------------------------
function ensureLogDir() {
  if (!fs.existsSync(LOG_DIR)) fs.mkdirSync(LOG_DIR, { recursive: true });
}
function writeLogLine(obj) {
  ensureLogDir();
  const line = JSON.stringify(obj) + "\n";
  fs.appendFileSync(LOG_FILE, line, { encoding: "utf-8" });
  // 콘솔도 출력
  // eslint-disable-next-line no-console
  console.log("[PT_LOG]", line.trim());
}

// ------------------------------
// API 핸들러
//   사용 예) GET /api/pt?region=서울특별시%20용산구%20이촌동
//   선택 파라미터) threshold (숫자), phrase (true/false)
// ------------------------------
export default async function handler(req, res) {
  try {
    const region = String(req.query.region || "").trim();
    const threshold =
      req.query.threshold != null ? Number(req.query.threshold) : null;
    const phrase = String(req.query.phrase || "false").toLowerCase() === "true";

    if (!region) {
      return res.status(400).json({
        ok: false,
        error: "region 쿼리를 입력하세요. (예: ?region=대전광역시 중구 유천2동)",
      });
    }

    const coords = findNxNy(region);
    if (!coords) {
      return res.status(404).json({
        ok: false,
        error: `지역 매칭 실패: "${region}" (법정동 공식명칭에 가깝게 입력해 주세요)`,
      });
    }
    const { nx, ny } = coords;

    const cacheKey = `${nx},${ny}`;
    const cached = getCache(cacheKey);
    const data = cached || (await fetchUltraNcst({ nx, ny }));
    if (!cached) setCache(cacheKey, data);
    
    const { temperature, humidity, windSpeed } = data;
    let apparent = null;
    let level = null;
    let action = null;
    
    if (temperature != null && humidity != null) {
      apparent = perceivedTempKMA(temperature, humidity);
      level = levelByPT(apparent);
      action = actionByLevel(level, apparent);
    }

    const legalThresholdMet =
      apparent != null ? apparent >= LEGAL_MIN_PT : null;

    // threshold 비교(요청자가 별도 기준을 줄 수 있음)
    let thresholdExceeded = null;
    if (threshold != null && apparent != null) {
      thresholdExceeded = apparent >= threshold;
    }

    const nowISO = new Date().toISOString();

    const response = {
      ok: true,
      region,
      grid: { nx, ny },
      observed: {
        ...data,
      },
      metrics: {
        apparentTemperature: apparent, // 체감온도
        level, // 관심/주의/경고/위험/정상
      },
      actions: {
        legalMinPT: LEGAL_MIN_PT,
        legalThresholdMet,
        suggestedAction: action, // 단계별 안내 문구
        customThreshold: threshold,
        customThresholdExceeded: thresholdExceeded,
      },
      system: {
        refreshIntervalMs: REFRESH_INTERVAL_MS, // 가이드 1시간 주기
        cache: {
          hit: Boolean(cached),
          ageMs: cached ? cached.cacheAgeMs : 0,
          ttlMs: CACHE_TTL_MS,
        },
        ts: nowISO,
      },
    };

    // --------------------------
    // 관리 기록 로깅 (요청 시마다)
    //   [타임스탬프, 조회지역, 체감온도, 경보단계, 조치사항]
    // --------------------------
    writeLogLine({
      ts: nowISO,
      region,
      nx,
      ny,
      temperature,
      humidity,
      windSpeed,
      apparentTemperature: apparent,
      level,
      action,
    });
    
    // phrase 모드(사전 브리핑 문장) 옵션
    if (phrase) {
      const ph =
        apparent != null
          ? `현재 ${region}의 기온은 ${temperature}℃, 습도 ${humidity}%, 체감온도는 ${apparent}℃(${level})입니다. ${action}`
          : `현재 ${region}의 실황 자료가 충분하지 않아 체감온도를 산출하지 못했습니다.`;
      return res.status(200).json({ ...response, phrase: ph });
    }

    return res.status(200).json(response);
  } catch (err) {
    // eslint-disable-next-line no-console
    console.error(err);
    return res.status(500).json({
      ok: false,
      error: String(err?.message || err),
    });
  }
}
```