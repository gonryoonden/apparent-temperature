좋아요. 에러의 “핵심 원인”과 바로 잡는 **최소 수정**을 정리해서 드릴게요—그리고 재실행 커맨드까지 한 번에.

---

## 왜 에러가 났나?

1. **pt 실행인데도 `pt-forecast.js`가 로드됨**
   현재 `scripts/invoke-api.mjs`가 두 엔드포인트를 **정적 import**하면, `pt`만 호출해도 `pt-forecast.js`가 함께 파싱됩니다.
   → 그 안의 `import { getVilageBaseDateTime } from "../lib/kmaForecast.js";`가 실패하며 중단.

2. **`lib/kmaForecast.js`에 `getVilageBaseDateTime`가 export되어 있지 않음**
   그래서 named import가 깨집니다.

---

## 바로 고치는 법 (딱 필요한 수정만)

### A) invoker를 **동적 import**로 교체 (pt 호출 시 forecast 파일을 아예 로드하지 않도록)

**`scripts/invoke-api.mjs`** (전체 교체해도 됨)

```js
// scripts/invoke-api.mjs
import 'dotenv/config';

function mockRes() {
  return {
    _code: 200,
    _body: null,
    status(c){ this._code=c; return this; },
    json(b){ this._body=b; console.log(JSON.stringify({status:this._code, ...b}, null, 2)); }
  };
}

const mode = process.argv[2] || "pt";
const region = process.argv.slice(3).join(' ') || "대전 와동";

const req = { query: { region }, body: {} };
const res = mockRes();

if (mode === "pt") {
  const mod = await import("../api/pt.js");              // ← 동적 import
  await mod.default(req, res);
} else {
  const mod = await import("../api/pt-forecast.js");     // ← 동적 import
  await mod.default(req, res);
}
```

### B) `pt-forecast.js`에서 문제의 import **삭제**하고, 베이스타임 함수를 **로컬로 구현**

**지금 파일 상단의 이 줄을 삭제:**

```js
import { getVilageBaseDateTime } from "../lib/kmaForecast.js";
```

**대신 `pt-forecast.js` 상단(다른 import 아래)에 아래 유틸 3개 + 함수 1개 추가:**

```js
// KST 시간 유틸 + 단기예보(8회) 베이스타임 산출
const toKST = (d = new Date()) => new Date(d.getTime() + 9 * 60 * 60 * 1000);
const pad2 = n => String(n).padStart(2, '0');
const yyyymmdd = d => `${d.getUTCFullYear()}${pad2(d.getUTCMonth()+1)}${pad2(d.getUTCDate())}`;

/**
 * getVilageBaseDateTime
 * - 발표시각: 02/05/08/11/14/17/20/23시
 * - 현재 시각(KST) 기준, 해당/이전 발표시각 중 가장 최근 것으로 선택
 * - 동일 시각에서는 분이 10분 이상일 때만 그 시각을 채택(여유 버퍼)
 */
function getVilageBaseDateTime(nowUTC = new Date()) {
  const kst = toKST(nowUTC);
  const slots = [2,5,8,11,14,17,20,23];
  const h = kst.getUTCHours();
  const m = kst.getUTCMinutes();
  let baseH = [...slots].reverse().find(H => H < h || (H === h && m >= 10));
  if (baseH == null) {
    // 첫 발표(02시) 이전: 전날 23시로
    baseH = 23;
    kst.setUTCDate(kst.getUTCDate() - 1);
  }
  return { base_date: yyyymmdd(kst), base_time: `${pad2(baseH)}00` };
}
```

### C) `pt-forecast.js`의 사소한 버그 2개 같이 정리

1. **정의 안 된 `adminKey` 사용** → `r.adminKey`로 교체
   아래 3곳 모두 교체하세요.

```diff
- return res.status(200).json({ ok:true, cache:{hit:true}, ...shapeForecast(cached, adminKey, {nx,ny}) });
+ return res.status(200).json({ ok:true, cache:{hit:true}, ...shapeForecast(cached, r.adminKey, {nx,ny}) });

- return res.status(200).json({ ok:true, cache:{hit:false, ttl:ttlSec}, ...shapeForecast(fc, adminKey, {nx,ny}) });
+ return res.status(200).json({ ok:true, cache:{hit:false, ttl:ttlSec}, ...shapeForecast(fc, r.adminKey, {nx,ny}) });

- return res.status(200).json({ ok:true, stale:true, note:'fallback_cache', ...shapeForecast(last, adminKey, {nx,ny}) });
+ return res.status(200).json({ ok:true, stale:true, note:'fallback_cache', ...shapeForecast(last, r.adminKey, {nx,ny}) });
```

2. **캐시 키 공백 제거(재확인)**
   이미 그렇게 하셨다면 스킵. 아니라면:

```diff
- const cacheKey = `${nx},${ny},vilage,${base_date} ${base_time}`;
+ const cacheKey = `${nx},${ny},vilage,${base_date}${base_time}`;
```

### D) (권장) `pt.js`의 사소한 두 군데도 예방 차원에서

1. **불필요한 체크 제거**
   파일 상단의 이 줄은 삭제하세요(정적 import 직후 참조 위험 + 무의미):

```diff
- if (!resolveRegion) throw new Error("resolveRegion not found in region-resolver.js");
```

2. **catch에서 쓰는 변수는 함수 스코프로 호이스팅**
   try 블록 안에서 선언된 `latestKey`, `regionRaw`, `nx`, `ny`, `debug`, `compat`, `phrase`를 catch에서 사용합니다.
   안전하게 맨 위에 먼저 선언만 해두고, try 내부에서 값을 할당하세요.

```diff
-export default async function handler(req, res) {
-  try {
+export default async function handler(req, res) {
+  let latestKey, regionRaw, nx, ny, debug, compat, phrase;
+  try {
-    const regionRaw = (getScalar(req.query.region) || "").trim();
+    regionRaw = (getScalar(req.query.region) || "").trim();
     ...
-    const phrase = parseBool(getScalar(req.query.phrase) || "false");
-    const compat = (getScalar(req.query.compat) || "").toLowerCase();
-    const debug = parseBool(getScalar(req.query.debug) || "false");
+    phrase = parseBool(getScalar(req.query.phrase) || "false");
+    compat = (getScalar(req.query.compat) || "").toLowerCase();
+    debug = parseBool(getScalar(req.query.debug) || "false");
     ...
-    const latestKey = `${nx},${ny},ultra,latest`;
+    latestKey = `${nx},${ny},ultra,latest`;
```

---

## 재실행

```bash
# pt만 실행할 때, 이제 forecast 파일이 로드되지 않습니다.
node scripts/invoke-api.mjs pt "서울 강남구 역삼동"

# forecast도 정상 동작 확인
node scripts/invoke-api.mjs forecast "대전 와동"
```

### 기대 결과

* 더 이상 `getVilageBaseDateTime` export 관련 SyntaxError가 나지 않습니다.
* 캐시가 붙어있다면 두 번째 호출에서 `cache.hit: true`(그리고 체감 빨라짐).

---

필요하면 두 파일을 **수정완료본**으로 통째로 보내드릴게요.
우선 위 4가지(특히 A, B)는 꼭 반영해주세요—이번 에러는 그 두 가지로 단번에 해결됩니다.
